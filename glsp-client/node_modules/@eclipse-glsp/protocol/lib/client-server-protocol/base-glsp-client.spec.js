"use strict";
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const util = require("util");
const test_util_1 = require("../utils/test-util");
const base_glsp_client_1 = require("./base-glsp-client");
const glsp_client_1 = require("./glsp-client");
class StubGLSPServer {
    initialize(params) {
        return Promise.resolve({ protocolVersion: '1.0.0', serverActions: {} });
    }
    initializeClientSession(params) {
        return Promise.resolve();
    }
    disposeClientSession(params) {
        return Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    process(message) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    shutdown() { }
    addListener(listener) {
        return false;
    }
    removeListener(listener) {
        return false;
    }
}
describe('Node GLSP Client', () => {
    const sandbox = sinon.createSandbox();
    const server = sandbox.stub(new StubGLSPServer());
    // Shared test client instance that is already in running state
    let client = new base_glsp_client_1.BaseGLSPClient({ id: 'test' });
    function resetClient(setRunning = true) {
        sandbox.reset();
        client = new base_glsp_client_1.BaseGLSPClient({ id: 'test' });
        if (setRunning) {
            client['_server'] = server;
            client['state'] = glsp_client_1.ClientState.Running;
        }
    }
    it('Should be in initial state after construction', () => {
        resetClient(false);
        (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Initial);
    });
    describe('start', () => {
        it('should fail if no server is configured', async () => {
            resetClient(false);
            client.setStartupTimeout(5);
            await (0, test_util_1.expectToThrowAsync)(() => client.start());
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.StartFailed);
        });
        it('Should resolve when server is configured', async () => {
            resetClient(false);
            client.configureServer(server);
            const result = await client.start();
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Running);
        });
    });
    describe('stop & onStop', () => {
        beforeEach(() => resetClient());
        it('onStop should not resolve if stop has not been called', () => {
            (0, chai_1.expect)(util.inspect(client.onStop())).to.include('pending');
        });
        it('should be in stopped state and onStop should resolve', async () => {
            (0, chai_1.expect)(client.currentState).to.be.not.equal(glsp_client_1.ClientState.Stopped);
            const stopResult = await client.stop();
            (0, chai_1.expect)(stopResult).to.be.undefined;
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Stopped);
            const onStopResult = await client.onStop();
            (0, chai_1.expect)(onStopResult).to.be.undefined;
            (0, chai_1.expect)(server.shutdown.calledOnce).to.be.true;
        });
    });
    describe('initialize', () => {
        it('should fail if server is not configured', async () => {
            resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.initializeServer({ applicationId: '', protocolVersion: '' }));
            (0, chai_1.expect)(server.initialize.called).to.be.false;
        });
        it('should fail if client is not running', async () => {
            resetClient(false);
            client.configureServer(server);
            await (0, test_util_1.expectToThrowAsync)(() => client.initializeServer({ applicationId: '', protocolVersion: '' }));
            (0, chai_1.expect)(server.initialize.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            resetClient();
            const expectedResult = { protocolVersion: '1.0.0', serverActions: {} };
            server.initialize.returns(Promise.resolve(expectedResult));
            (0, chai_1.expect)(client.initializeResult).to.be.undefined;
            const result = await client.initializeServer({ applicationId: 'id', protocolVersion: '1.0.0' });
            (0, chai_1.expect)(result).to.deep.equals(expectedResult);
            (0, chai_1.expect)(server.initialize.calledOnce).to.be.true;
            (0, chai_1.expect)(client.initializeResult).to.be.equal(result);
        });
        it('should return cached result on consecutive invocation', async () => {
            await resetClient();
            const expectedResult = { protocolVersion: '1.0.0', serverActions: {} };
            const params = { applicationId: 'id', protocolVersion: '1.0.0' };
            server.initialize.returns(Promise.resolve(expectedResult));
            client['_initializeResult'] = expectedResult;
            const result = await client.initializeServer(params);
            (0, chai_1.expect)(result).to.be.deep.equal(client.initializeResult);
            (0, chai_1.expect)(server.initialize.called).to.be.false;
        });
        it('should fire event on first invocation', async () => {
            await resetClient();
            const expectedResult = { protocolVersion: '1.0.0', serverActions: {} };
            const params = { applicationId: 'id', protocolVersion: '1.0.0' };
            server.initialize.returns(Promise.resolve(expectedResult));
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            const eventHandler = (result) => { };
            const eventHandlerSpy = sinon.spy(eventHandler);
            client.onServerInitialized(eventHandlerSpy);
            await client.initializeServer(params);
            await client.initializeServer(params);
            (0, chai_1.expect)(eventHandlerSpy.calledOnceWith(expectedResult)).to.be.true;
        });
    });
    describe('initializeClientSession', () => {
        it('should fail if server is not configured', async () => {
            resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.initializeClientSession({ clientSessionId: '', diagramType: '', clientActionKinds: [] }));
            (0, chai_1.expect)(server.initializeClientSession.called).to.be.false;
        });
        it('should fail if client is not running', async () => {
            resetClient(false);
            client.configureServer(server);
            await (0, test_util_1.expectToThrowAsync)(() => client.initializeClientSession({ clientSessionId: '', diagramType: '', clientActionKinds: [] }));
            (0, chai_1.expect)(server.initializeClientSession.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            resetClient();
            const result = await client.initializeClientSession({ clientSessionId: '', diagramType: '', clientActionKinds: [] });
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(server.initializeClientSession.calledOnce).to.be.true;
        });
    });
    describe('disposeClientSession', () => {
        it('should fail if server is not configured', async () => {
            resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.disposeClientSession({ clientSessionId: '' }));
            (0, chai_1.expect)(server.disposeClientSession.called).to.be.false;
        });
        it('should fail if client is not running', async () => {
            resetClient(false);
            client.configureServer(server);
            await (0, test_util_1.expectToThrowAsync)(() => client.disposeClientSession({ clientSessionId: '' }));
            (0, chai_1.expect)(server.disposeClientSession.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            resetClient();
            const result = await client.disposeClientSession({ clientSessionId: '' });
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(server.disposeClientSession.calledOnce).to.be.true;
        });
    });
    describe('shutdownServer', () => {
        it('should fail if server is not configured', () => {
            resetClient(false);
            (0, chai_1.expect)(() => client.shutdownServer()).to.throw();
            (0, chai_1.expect)(server.shutdown.called).to.be.false;
        });
        it('should fail if client is not running', () => {
            resetClient(false);
            client.configureServer(server);
            (0, chai_1.expect)(() => client.shutdownServer()).to.throw();
            (0, chai_1.expect)(server.shutdown.called).to.be.false;
        });
        it('should invoke the corresponding server method', () => {
            resetClient();
            client.shutdownServer();
            (0, chai_1.expect)(server.shutdown.calledOnce).to.be.true;
        });
    });
    describe('sendActionMessage', () => {
        it('should fail if server is not configured', () => {
            resetClient(false);
            (0, chai_1.expect)(() => client.sendActionMessage({ action: { kind: '' }, clientId: '' })).to.throw();
            (0, chai_1.expect)(server.process.called).to.be.false;
        });
        it('should fail if client is not running', () => {
            resetClient(false);
            client.configureServer(server);
            (0, chai_1.expect)(() => client.sendActionMessage({ action: { kind: '' }, clientId: '' })).to.throw();
            (0, chai_1.expect)(server.process.called).to.be.false;
        });
        it('should invoke the corresponding server method', () => {
            resetClient();
            client.sendActionMessage({ action: { kind: '' }, clientId: '' });
            (0, chai_1.expect)(server.process.calledOnce).to.be.true;
        });
    });
    describe('onActionMessage', () => {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const handler = sandbox.spy((_message) => { });
        it('should be properly registered if server is not configured', () => {
            var _a;
            resetClient(false);
            client.onActionMessage(handler);
            (0, chai_1.expect)((_a = client['actionMessageHandlers'].get(base_glsp_client_1.GLOBAL_HANDLER_ID)) === null || _a === void 0 ? void 0 : _a.length).to.be.equal(1);
            (0, chai_1.expect)(handler.called).to.be.false;
        });
        it('should be properly registered if client is not running', () => {
            var _a;
            resetClient(false);
            client.configureServer(server);
            client.onActionMessage(handler);
            (0, chai_1.expect)((_a = client['actionMessageHandlers'].get(base_glsp_client_1.GLOBAL_HANDLER_ID)) === null || _a === void 0 ? void 0 : _a.length).to.be.equal(1);
            (0, chai_1.expect)(handler.called).to.be.false;
        });
        it('should unregister global handler if dispose is invoked', () => {
            var _a, _b;
            resetClient(false);
            const toDispose = client.onActionMessage(handler);
            (0, chai_1.expect)((_a = client['actionMessageHandlers'].get(base_glsp_client_1.GLOBAL_HANDLER_ID)) === null || _a === void 0 ? void 0 : _a.length).to.be.equal(1);
            toDispose.dispose();
            (0, chai_1.expect)((_b = client['actionMessageHandlers'].get(base_glsp_client_1.GLOBAL_HANDLER_ID)) === null || _b === void 0 ? void 0 : _b.length).to.be.equal(0);
        });
        it('should unregister client id handler if dispose is invoked', () => {
            var _a;
            resetClient(false);
            const clientId = 'clientId';
            const toDispose = client.onActionMessage(handler, clientId);
            (0, chai_1.expect)(client['actionMessageHandlers'].size).to.be.equal(2);
            toDispose.dispose();
            (0, chai_1.expect)((_a = client['actionMessageHandlers'].get(clientId)) === null || _a === void 0 ? void 0 : _a.length).to.be.equal(0);
        });
        it('should invoke global handler when the an action message is sent via proxy', () => {
            resetClient();
            client.onActionMessage(handler);
            const expectedMessage = { action: { kind: 'someAction' }, clientId: 'someClientId' };
            client.proxy.process(expectedMessage);
            (0, chai_1.expect)(handler.calledOnce).to.be.true;
            (0, chai_1.expect)(handler.firstCall.args[0]).to.deep.equals(expectedMessage);
        });
        it('should invoke client id handler when the an action message is sent via proxy', () => {
            resetClient();
            const clientId = 'clientId';
            client.onActionMessage(handler, clientId);
            const expectedMessage = { action: { kind: 'someAction' }, clientId };
            client.proxy.process(expectedMessage);
            client.proxy.process({ clientId: 'someOtherId', action: { kind: 'someAction' } });
            (0, chai_1.expect)(handler.calledOnce).to.be.true;
            (0, chai_1.expect)(handler.firstCall.args[0]).to.deep.equals(expectedMessage);
        });
    });
});
//# sourceMappingURL=base-glsp-client.spec.js.map