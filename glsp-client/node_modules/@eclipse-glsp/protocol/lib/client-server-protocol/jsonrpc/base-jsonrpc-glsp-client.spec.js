"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-empty-function */
const chai_1 = require("chai");
const sinon = require("sinon");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
const array_util_1 = require("../../utils/array-util");
const test_util_1 = require("../../utils/test-util");
const glsp_client_1 = require("../glsp-client");
const base_jsonrpc_glsp_client_1 = require("./base-jsonrpc-glsp-client");
const glsp_jsonrpc_client_1 = require("./glsp-jsonrpc-client");
class StubMessageConnection {
    constructor() {
        this.mockEvent = (listener, thisArgs, disposables) => vscode_jsonrpc_1.Disposable.create(() => { });
        this.onUnhandledProgress = this.mockEvent;
        this.onError = this.mockEvent;
        this.onClose = this.mockEvent;
        this.onUnhandledNotification = this.mockEvent;
        this.onDispose = this.mockEvent;
    }
    sendRequest(...args) {
        throw new Error('Method not implemented.');
    }
    onRequest(...args) {
        return vscode_jsonrpc_1.Disposable.create(() => { });
    }
    hasPendingResponse() {
        return false;
    }
    sendNotification(...args) {
        return Promise.resolve();
    }
    onNotification(...args) {
        return vscode_jsonrpc_1.Disposable.create(() => { });
    }
    onProgress(type, token, handler) {
        throw new Error('Method not implemented.');
    }
    sendProgress(type, token, value) {
        throw new Error('Method not implemented.');
    }
    trace(...args) {
        return Promise.resolve();
    }
    listen() { }
    end() { }
    dispose() { }
    inspect() { }
}
describe('Base JSON-RPC GLSP Client', () => {
    const sandbox = sinon.createSandbox();
    const connection = sandbox.stub(new StubMessageConnection());
    let client = new base_jsonrpc_glsp_client_1.BaseJsonrpcGLSPClient({ id: 'test', connectionProvider: connection });
    async function resetClient(setRunning = true) {
        sandbox.reset();
        client = new base_jsonrpc_glsp_client_1.BaseJsonrpcGLSPClient({ id: 'test', connectionProvider: connection });
        if (setRunning) {
            return client.start();
        }
    }
    describe('start', () => {
        it('should successfully start & activate the connection', async () => {
            await resetClient(false);
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Initial);
            client.start();
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Starting);
            const result = await client.start();
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Running);
            (0, chai_1.expect)(client.isConnectionActive()).to.be.true;
        });
    });
    describe('stop', () => {
        it('should successfully stop if the client was not running', async () => {
            await resetClient(false);
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Initial);
            const stopResult = await client.stop();
            (0, chai_1.expect)(stopResult).to.be.undefined;
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Stopped);
        });
        it('should successfully stop if the client was running', async () => {
            await resetClient();
            client.stop();
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Stopping);
            const stopResult = await client.stop();
            (0, chai_1.expect)(stopResult).to.be.undefined;
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.Stopped);
        });
    });
    describe('initialize', () => {
        it('should fail if client is not running', async () => {
            await resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.initializeServer({ applicationId: '', protocolVersion: '' }));
            (0, chai_1.expect)(connection.sendRequest.called).to.be.false;
        });
        it('should forward the corresponding initialize request and cache result', async () => {
            await resetClient();
            const expectedResult = { protocolVersion: '1.0.0', serverActions: {} };
            const params = { applicationId: 'id', protocolVersion: '1.0.0' };
            const initializeMock = connection.sendRequest.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest, params);
            initializeMock.returns(expectedResult);
            (0, chai_1.expect)(client.initializeResult).to.be.undefined;
            const result = await client.initializeServer({ applicationId: 'id', protocolVersion: '1.0.0' });
            (0, chai_1.expect)(result).to.deep.equals(expectedResult);
            (0, chai_1.expect)(initializeMock.calledOnce).to.be.true;
            (0, chai_1.expect)(client.initializeResult).to.be.equal(result);
        });
        it('should return cached result on consecutive invocation', async () => {
            await resetClient();
            const expectedResult = { protocolVersion: '1.0.0', serverActions: {} };
            const params = { applicationId: 'id', protocolVersion: '1.0.0' };
            const initializeMock = connection.sendRequest.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest, params);
            initializeMock.returns(expectedResult);
            client['_initializeResult'] = expectedResult;
            const result = await client.initializeServer({ applicationId: 'id', protocolVersion: '1.0.0' });
            (0, chai_1.expect)(result).to.be.deep.equal(client.initializeResult);
            (0, chai_1.expect)(initializeMock.called).to.be.false;
        });
        it('should fire event on first invocation', async () => {
            await resetClient();
            const expectedResult = { protocolVersion: '1.0.0', serverActions: {} };
            const params = { applicationId: 'id', protocolVersion: '1.0.0' };
            const initializeMock = connection.sendRequest.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest, params);
            initializeMock.returns(expectedResult);
            const eventHandler = (result) => { };
            const eventHandlerSpy = sinon.spy(eventHandler);
            client.onServerInitialized(eventHandlerSpy);
            await client.initializeServer(params);
            await client.initializeServer(params);
            (0, chai_1.expect)(eventHandlerSpy.calledOnceWith(expectedResult)).to.be.true;
        });
    });
    describe('initializeClientSession', () => {
        it('should fail if client is not running', async () => {
            await resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.initializeClientSession({ clientSessionId: '', diagramType: '', clientActionKinds: [] }));
            (0, chai_1.expect)(connection.sendRequest.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            await resetClient();
            const params = { clientSessionId: '', diagramType: '', clientActionKinds: [] };
            const initializeSessionMock = connection.sendRequest.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, params);
            const result = await client.initializeClientSession(params);
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(initializeSessionMock.calledOnce).to.be.true;
        });
    });
    describe('disposeClientSession', () => {
        it('should fail if client is not running', async () => {
            await resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.disposeClientSession({ clientSessionId: '' }));
            (0, chai_1.expect)(connection.sendRequest.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            await resetClient();
            const params = { clientSessionId: 'someClient' };
            const disposeSessionMock = connection.sendRequest.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, params);
            const result = await client.disposeClientSession(params);
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(disposeSessionMock.calledOnce).to.be.true;
        });
    });
    describe('shutdownServer', () => {
        it('should fail if client is not running', async () => {
            await resetClient(false);
            (0, chai_1.expect)(() => client.shutdownServer()).to.throw();
            (0, chai_1.expect)(connection.sendNotification.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            await resetClient();
            const shutdownMock = connection.sendNotification.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ShutdownNotification);
            const result = await client.shutdownServer();
            (0, chai_1.expect)(result).to.be.undefined;
            (0, chai_1.expect)(shutdownMock.calledOnce).to.be.true;
        });
    });
    describe('sendActionMessage', () => {
        it('should fail if client is not running', async () => {
            await resetClient(false);
            (0, chai_1.expect)(() => client.sendActionMessage({ action: { kind: '' }, clientId: '' })).to.throw();
            (0, chai_1.expect)(connection.sendNotification.called).to.be.false;
        });
        it('should invoke the corresponding server method', async () => {
            await resetClient();
            const message = { action: { kind: '' }, clientId: '' };
            const messageMock = connection.sendNotification.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
            client.sendActionMessage({ action: { kind: '' }, clientId: '' });
            (0, chai_1.expect)(messageMock.calledOnce).to.be.true;
        });
    });
    describe('onActionMessage', () => {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const handler = sandbox.spy((_message) => { });
        it('should fail if client is not running', async () => {
            await resetClient(false);
            await (0, test_util_1.expectToThrowAsync)(() => client.onActionMessage(handler));
            (0, chai_1.expect)(connection.onNotification.called).to.be.false;
        });
        it('should invoked the corresponding connection method', async () => {
            await resetClient();
            client.onActionMessage(handler, 'someId');
            (0, chai_1.expect)(connection.onNotification.withArgs(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification).calledOnce).to.be.true;
        });
    });
    describe('Connection events', () => {
        it('Should be in error state after connection error', async () => {
            // mock setup
            resetClient(false);
            const listeners = [];
            connection.onError.callsFake(listener => {
                listeners.push(listener);
                return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(listeners, listener));
            });
            await client.start();
            listeners.forEach(listener => listener(new Error('SomeError')));
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.ServerError);
        });
        it('Should be in error state after connection close while running', async () => {
            // mock setup
            resetClient(false);
            const listeners = [];
            connection.onClose.callsFake(listener => {
                listeners.push(listener);
                return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(listeners, listener));
            });
            await client.start();
            listeners.forEach(listener => listener(undefined));
            (0, chai_1.expect)(client.currentState).to.be.equal(glsp_client_1.ClientState.ServerError);
        });
    });
});
//# sourceMappingURL=base-jsonrpc-glsp-client.spec.js.map