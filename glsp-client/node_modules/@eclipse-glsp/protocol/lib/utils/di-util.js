"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindAsService = exports.lazyBind = exports.bindOrRebind = exports.FeatureModule = exports.resolveContainerConfiguration = exports.initializeContainer = void 0;
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = require("inversify");
const array_util_1 = require("./array-util");
const type_util_1 = require("./type-util");
/**
 * Initializes a container with the given {@link ContainerConfiguration}. The container configuration
 * consists of the set of {@link ContainerModule}s that should be loaded in the container.
 * In addition, for more fine-grained control {@link ModuleConfiguration}s can be passed as part fo the container configuration
 * Module loading is distinct,this means each module will only get loaded once even if it is configured multiple times.
  @param containerConfigurations
 *          Custom modules to be loaded in addition to the default modules and/or default modules that should be excluded.
  @returns The initialized container.
 */
function initializeContainer(container, ...containerConfigurations) {
    const modules = resolveContainerConfiguration(...containerConfigurations);
    container.load(...modules);
    return container;
}
exports.initializeContainer = initializeContainer;
/**
 *  Processes the given container configurations and returns the corresponding set of {@link ContainerModule}s.
 * @param containerConfigurations The container configurations to resolves
 * @returns an Array of resolved container modules
 */
function resolveContainerConfiguration(...containerConfigurations) {
    const modules = [];
    containerConfigurations.forEach(config => {
        if (isContainerModule(config)) {
            (0, array_util_1.distinctAdd)(modules, config);
        }
        else {
            if (config.remove) {
                (0, array_util_1.remove)(modules, ...(0, array_util_1.asArray)(config.remove));
            }
            if (config.add) {
                (0, array_util_1.distinctAdd)(modules, ...(0, array_util_1.asArray)(config.add));
            }
        }
    });
    return modules;
}
exports.resolveContainerConfiguration = resolveContainerConfiguration;
/**
 * The container modules might originate form different inversify contexts (e.g. `inversify` vs. `@theia/core/shared/inversify`).
 * If this is the case an instanceof check can return  false negative.
 * => use a simple typeguard instead.
 */
function isContainerModule(config) {
    return (0, type_util_1.hasNumberProp)(config, 'id') && (0, type_util_1.hasFunctionProp)(config, 'registry');
}
/**
 * A `FeatureModule` is a specialized {@link ContainerModule} that can declare dependencies to other {@link FeatureModule}.
 * A feature module will only be loaded into a container if all of its required modules haven been loaded before. T
 * Each feature module binds its `featureId` be default. This enables querying of existing container to check wether a
 * feature module has been loaded into this container.
 */
class FeatureModule extends inversify_1.ContainerModule {
    constructor(registry, options = {}) {
        var _a;
        super((bind, unbind, isBound, ...rest) => {
            if (this.configure(bind, isBound)) {
                registry(bind, unbind, isBound, ...rest);
            }
        });
        this.featureId = (_a = options.featureId) !== null && _a !== void 0 ? _a : this.createFeatureId();
        this.requires = options.requires;
    }
    createFeatureId() {
        return Symbol(this.id);
    }
    /**
     * Configures the feature module i.e. checks if the requirements are met.
     * If this is the case the {@link FeatureModule.featureId} will be bound and the module will be loaded
     * @param bind container bind function
     * @param isBound container isBound function
     * @returns `true` if all requirements are met and the module is loaded. `false` otherwise
     */
    configure(bind, isBound) {
        if (this.checkRequirements(isBound)) {
            bind(this.featureId).toConstantValue(this.featureId);
            return true;
        }
        return false;
    }
    /**
     * Checks if all required {@link FeatureModule}s are already loaded/bound in the container.
     * @param isBound The `isBound` property of the module callback. Used to check the required modules.
     * @returns `true` if all requirements are met, `false` otherwise
     */
    checkRequirements(isBound) {
        return this.requires ? (0, array_util_1.asArray)(this.requires).every(module => isBound(module.featureId)) : true;
    }
    isLoaded(context) {
        return context.isBound(this.featureId);
    }
}
exports.FeatureModule = FeatureModule;
/**
 * Checks wether the given service identifier is already bound in the given context
 * then either calls  the `bind` or `rebind` function respectively.
 *
 * As this is just a convenience function
 * ```ts
 * bindOrRebind({bind,isBound,rebind}, MyService).to(SomeOtherService);
 * ```
 * is equivalent to:
 * ```
 * if (isBound(MyService)) {
 *    rebind(MyService).to(SomeOtherService);
 * } else {
 *    bind(MyService).to(SomeOtherService);
 * }
 * ```
 * @param context The binding context
 * @param serviceIdentifier The service identifier
 * @returns The result of the `bind` or `rebind` function
 */
function bindOrRebind(context, serviceIdentifier) {
    if (context.isBound(serviceIdentifier)) {
        return context.rebind(serviceIdentifier);
    }
    return context.bind(serviceIdentifier);
}
exports.bindOrRebind = bindOrRebind;
/**
 * Only binds the given service identifier if it's not already bound in the given context.
 *
 * As this is just a convenience function
 * ```ts
 * lazyBind({bind,isBound}, MyService)?.to(SomeOtherService);
 * ```
 * is equivalent to:
 * ```
 * if (!isBound(MyService)) {
 *    bind(MyService).to(SomeOtherService);
 * }
 * ```
 * @param context The binding context
 * @param serviceIdentifier The service identifier
 * @returns The result of the `bind` function or `undefined` if the service was already bound
 */
function lazyBind(context, serviceIdentifier) {
    if (context.isBound(serviceIdentifier)) {
        return undefined;
    }
    return context.bind(serviceIdentifier);
}
exports.lazyBind = lazyBind;
/**
 * Binds the given service identifier to the given target service in the given context.
 * In addition, the target service is bound to itself in singleton scope. This ensures
 * that services can be rebound individually even if they are multi-injected.
 *
 * As this is just a convenience function
 * ```ts
 * bindAsService(bind,SomeOtherService,MyServiceImpl);
 * ```
 * is equivalent to:
 * ```ts
 * bind(MyServiceImpl).toSelf.inSingletonScope():
 * bind(SomeOtherService).toService(MyServiceImpl);
 * ```
 * @param serviceIdentifier
 * @param toServiceIdentifier
 */
function bindAsService(context, serviceIdentifier, targetService) {
    const bind = typeof context === 'object' ? context.bind.bind(context) : context;
    bind(targetService).toSelf().inSingletonScope();
    bind(serviceIdentifier).toService(targetService);
}
exports.bindAsService = bindAsService;
//# sourceMappingURL=di-util.js.map