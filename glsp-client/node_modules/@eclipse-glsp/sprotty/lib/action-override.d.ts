/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Action, LabeledAction, Point } from '@eclipse-glsp/protocol';
import { VNode } from 'snabbdom';
import { SButtonImpl as GButton, SModelElementImpl as GModelElement, SModelRootImpl as GModelRoot, ICommand, IActionHandler as SIActionHandler, IButtonHandler as SIButtonHandler, ICommandPaletteActionProvider as SICommandPaletteActionProvider, IContextMenuItemProvider as SIContextMenuItemProvider, KeyListener as SKeyListener, MouseListener as SMouseListener } from 'sprotty';
/**
 * An action handler accepts an action and reacts to it by returning either a command to be
 * executed, or another action to be dispatched.
 */
export interface IActionHandler extends SIActionHandler {
    handle(action: Action): ICommand | Action | void;
}
export interface IButtonHandler extends SIButtonHandler {
    buttonPressed(button: GButton): (Action | Promise<Action>)[];
}
export interface ICommandPaletteActionProvider extends SICommandPaletteActionProvider {
    getActions(root: Readonly<GModelRoot>, text: string, lastMousePosition?: Point, index?: number): Promise<LabeledAction[]>;
}
export interface IContextMenuItemProvider extends SIContextMenuItemProvider {
    getItems(root: Readonly<GModelRoot>, lastMousePosition?: Point): Promise<LabeledAction[]>;
}
export declare class KeyListener extends SKeyListener {
    keyDown(element: GModelElement, event: KeyboardEvent): Action[];
    keyUp(element: GModelElement, event: KeyboardEvent): Action[];
}
export declare class MouseListener extends SMouseListener {
    mouseOver(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    mouseOut(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    mouseEnter(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    mouseLeave(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    mouseDown(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    mouseMove(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    mouseUp(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    wheel(target: GModelElement, event: WheelEvent): (Action | Promise<Action>)[];
    doubleClick(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    contextMenu(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    dragOver(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    drop(target: GModelElement, event: MouseEvent): (Action | Promise<Action>)[];
    decorate(vnode: VNode, element: GModelElement): VNode;
}
//# sourceMappingURL=action-override.d.ts.map