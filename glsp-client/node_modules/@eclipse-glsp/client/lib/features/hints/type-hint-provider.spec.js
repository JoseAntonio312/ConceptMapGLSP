"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const chai_1 = require("chai");
const inversify_1 = require("inversify");
const sinon = require("sinon");
const action_dispatcher_1 = require("../../base/action-dispatcher");
const feedback_action_dispatcher_1 = require("../../base/feedback/feedback-action-dispatcher");
const model_1 = require("../../model");
const model_2 = require("../change-bounds/model");
const model_3 = require("../reconnect/model");
const model_4 = require("./model");
const type_hint_provider_1 = require("./type-hint-provider");
describe('TypeHintProvider', () => {
    const container = new inversify_1.Container();
    container.bind(action_dispatcher_1.GLSPActionDispatcher).toConstantValue(sinon.createStubInstance(action_dispatcher_1.GLSPActionDispatcher));
    container.bind(sprotty_1.TYPES.IFeedbackActionDispatcher).toConstantValue(sinon.createStubInstance(feedback_action_dispatcher_1.FeedbackActionDispatcher));
    const typeHintProvider = container.resolve(type_hint_provider_1.TypeHintProvider);
    describe('getShapeTypeHint', () => {
        const nodeHint = {
            deletable: true,
            elementTypeId: 'node',
            reparentable: false,
            repositionable: true,
            resizable: true
        };
        const taskHint = {
            deletable: true,
            elementTypeId: 'node:task',
            reparentable: false,
            repositionable: true,
            resizable: true
        };
        it('should return `undefined` if no `SetTypeHintsAction` has been handled yet', () => {
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('some')).to.be.undefined;
        });
        it('should return `undefined` if no hint is registered for the given type (exact type match)', () => {
            typeHintProvider.handle(sprotty_1.SetTypeHintsAction.create({ shapeHints: [nodeHint], edgeHints: [] }));
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('port')).to.be.undefined;
        });
        it('should return the corresponding type hint for the given type (exact type match)', () => {
            typeHintProvider.handle(sprotty_1.SetTypeHintsAction.create({ shapeHints: [nodeHint, taskHint], edgeHints: [] }));
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('node')).to.equal(nodeHint);
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('node:task')).to.equal(taskHint);
        });
        it('should return the corresponding type hint for the given type (sub type match)', () => {
            typeHintProvider.handle(sprotty_1.SetTypeHintsAction.create({ shapeHints: [nodeHint, taskHint], edgeHints: [] }));
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('node:task:manual')).to.equal(taskHint);
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('node:task:manual:foo')).to.equal(taskHint);
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('node:event')).to.equal(nodeHint);
            (0, chai_1.expect)(typeHintProvider.getShapeTypeHint('node:event:initial')).to.equal(nodeHint);
        });
    });
    describe('getEdgeTypeHint', () => {
        const edgeHint = {
            deletable: true,
            elementTypeId: 'edge',
            repositionable: true,
            routable: true,
            dynamic: false
        };
        const fooEdgeHint = {
            deletable: true,
            elementTypeId: 'edge:foo',
            repositionable: true,
            routable: true,
            dynamic: true
        };
        it('should return `undefined` if no `SetTypeHintsAction` has been handled yet', () => {
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('some')).to.be.undefined;
        });
        it('should return `undefined` if no hint is registered for the given type (exact type match)', () => {
            typeHintProvider.handle(sprotty_1.SetTypeHintsAction.create({ shapeHints: [], edgeHints: [edgeHint] }));
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('link')).to.be.undefined;
        });
        it('should return the corresponding type hint for the given type (exact type match)', () => {
            typeHintProvider.handle(sprotty_1.SetTypeHintsAction.create({ shapeHints: [], edgeHints: [edgeHint, fooEdgeHint] }));
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('edge')).to.equal(edgeHint);
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('edge:foo')).to.equal(fooEdgeHint);
        });
        it('should return the corresponding type hint for the given type (sub type match)', () => {
            typeHintProvider.handle(sprotty_1.SetTypeHintsAction.create({ shapeHints: [], edgeHints: [edgeHint, fooEdgeHint] }));
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('edge:foo:bar')).to.equal(fooEdgeHint);
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('edge:foo:bar:baz')).to.equal(fooEdgeHint);
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('edge:some')).to.equal(edgeHint);
            (0, chai_1.expect)(typeHintProvider.getEdgeTypeHint('edge:some:other')).to.equal(edgeHint);
        });
    });
});
describe('ApplyTypeHintCommand', () => {
    function createCommandExecutionContext(child) {
        const root = new sprotty_1.GModelRoot();
        root.id = 'root';
        root.type = 'root';
        root.add(child);
        return {
            root,
            modelFactory,
            duration: 0,
            modelChanged: undefined,
            logger: new sprotty_1.ConsoleLogger(),
            syncer: new sprotty_1.AnimationFrameSyncer()
        };
    }
    function createNode(type) {
        const node = new sprotty_1.GNode();
        node.type = type !== null && type !== void 0 ? type : 'node';
        node.id = 'node';
        node.features = (0, sprotty_1.createFeatureSet)(sprotty_1.GNode.DEFAULT_FEATURES);
        return node;
    }
    function createEdge(type) {
        const edge = new model_1.GEdge();
        edge.type = type !== null && type !== void 0 ? type : 'edge';
        edge.id = 'edge';
        edge.features = (0, sprotty_1.createFeatureSet)(model_1.GEdge.DEFAULT_FEATURES);
        return edge;
    }
    const sandbox = sinon.createSandbox();
    const container = new inversify_1.Container();
    const modelFactory = sinon.createStubInstance(sprotty_1.GModelFactory);
    const typeHintProviderMock = sandbox.stub({
        getEdgeTypeHint: () => undefined,
        getShapeTypeHint: () => undefined
    });
    container.bind(action_dispatcher_1.GLSPActionDispatcher).toConstantValue(sandbox.createStubInstance(action_dispatcher_1.GLSPActionDispatcher));
    container.bind(sprotty_1.TYPES.IFeedbackActionDispatcher).toConstantValue(sandbox.createStubInstance(feedback_action_dispatcher_1.FeedbackActionDispatcher));
    container.bind(sprotty_1.TYPES.ITypeHintProvider).toConstantValue(typeHintProviderMock);
    (0, sprotty_1.bindOrRebind)(container, sprotty_1.TYPES.Action).toConstantValue(type_hint_provider_1.ApplyTypeHintsAction.create());
    const command = container.resolve(type_hint_provider_1.ApplyTypeHintsCommand);
    beforeEach(() => {
        sandbox.reset();
    });
    describe('test hints to model feature translation (after command execution)`', () => {
        describe('ShapeTypeHint', () => {
            const allEnabledHint = {
                elementTypeId: 'node',
                deletable: true,
                reparentable: true,
                repositionable: true,
                resizable: true,
                containableElementTypeIds: []
            };
            const allDisabledHint = {
                elementTypeId: 'node',
                deletable: false,
                reparentable: false,
                repositionable: false,
                resizable: false,
                containableElementTypeIds: []
            };
            it('should not modify feature set of model element with no applicable type hint', () => {
                typeHintProviderMock.getShapeTypeHint.returns(undefined);
                const result = command.execute(createCommandExecutionContext(createNode()));
                const element = result.children[0];
                (0, chai_1.expect)(sprotty_1.GNode.DEFAULT_FEATURES, 'Element should have default feature set').to.have.same.members([
                    ...element.features
                ]);
            });
            it('should add all enabled (`true`) features, derived from the applied type hint, to the model', () => {
                typeHintProviderMock.getShapeTypeHint.returns(allEnabledHint);
                const result = command.execute(createCommandExecutionContext(createNode()));
                const element = result.children[0];
                (0, chai_1.expect)((0, sprotty_1.isDeletable)(element), 'Element should have deletable feature').to.be.true;
                (0, chai_1.expect)((0, model_4.isReparentable)(element), 'Element should have reparentable feature').to.be.true;
                (0, chai_1.expect)((0, sprotty_1.isMoveable)(element), 'Element should have moveable feature').to.be.true;
                (0, chai_1.expect)((0, model_4.isContainable)(element), 'Element should have containable feature').to.be.true;
                (0, chai_1.expect)((0, model_2.isResizable)(element), 'Element should have resizeable feature').to.be.true;
            });
            it('should remove all disabled (`false`) features, derived from the applied type hint, from the model', () => {
                typeHintProviderMock.getShapeTypeHint.returns(allDisabledHint);
                const result = command.execute(createCommandExecutionContext(createNode()));
                const element = result.children[0];
                (0, chai_1.expect)((0, sprotty_1.isDeletable)(element), 'Element should not have deletable feature').to.be.false;
                (0, chai_1.expect)((0, model_4.isReparentable)(element), 'Element should  not have reparentable feature').to.be.false;
                (0, chai_1.expect)((0, sprotty_1.isMoveable)(element), 'Element should  not have moveable feature').to.be.false;
                (0, chai_1.expect)((0, model_2.isResizable)(element), 'Element should not have resizeable feature').to.be.false;
            });
            describe('`isConnectable` (after hint has been applied to element)', () => {
                const shapeHint = {
                    deletable: false,
                    elementTypeId: 'node',
                    reparentable: false,
                    repositionable: false,
                    resizable: false
                };
                const edgeHint = {
                    deletable: false,
                    elementTypeId: 'edge',
                    repositionable: false,
                    routable: false
                };
                it('should return `true` if source/target elements are not defined in edge hint', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    typeHintProviderMock.getEdgeTypeHint.returns(edgeHint);
                    const result = command.execute(createCommandExecutionContext(createNode()));
                    const element = result.children[0];
                    const edge = createEdge();
                    (0, chai_1.expect)(element.canConnect(edge, 'source')).to.be.true;
                    (0, chai_1.expect)(element.canConnect(edge, 'target')).to.be.true;
                });
                it('should return `false` if element type is not in source/target elements of edge hint', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    typeHintProviderMock.getEdgeTypeHint.returns(edgeHint);
                    edgeHint.sourceElementTypeIds = [];
                    edgeHint.targetElementTypeIds = [];
                    const result = command.execute(createCommandExecutionContext(createNode()));
                    const element = result.children[0];
                    const edge = createEdge();
                    (0, chai_1.expect)(element.canConnect(edge, 'source')).to.be.false;
                    (0, chai_1.expect)(element.canConnect(edge, 'target')).to.be.false;
                });
                it('should return `true` if element type is in source/target elements of edge hint (exact type)', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    typeHintProviderMock.getEdgeTypeHint.returns(edgeHint);
                    edgeHint.sourceElementTypeIds = ['node'];
                    edgeHint.targetElementTypeIds = ['node'];
                    const result = command.execute(createCommandExecutionContext(createNode()));
                    const element = result.children[0];
                    const edge = createEdge();
                    (0, chai_1.expect)(element.canConnect(edge, 'source')).to.be.true;
                    (0, chai_1.expect)(element.canConnect(edge, 'target')).to.be.true;
                });
                it('should return `true` if element super type is in source/target elements of edge hint (super type)', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    typeHintProviderMock.getEdgeTypeHint.returns(edgeHint);
                    edgeHint.sourceElementTypeIds = ['node'];
                    edgeHint.targetElementTypeIds = ['node'];
                    const result = command.execute(createCommandExecutionContext(createNode('node:task:automated')));
                    const element = result.children[0];
                    const edge = createEdge();
                    (0, chai_1.expect)(element.canConnect(edge, 'source')).to.be.true;
                    (0, chai_1.expect)(element.canConnect(edge, 'target')).to.be.true;
                });
                it('should fallback to class-level `canConnect` implementation if no edge hint is applicable to routable', () => {
                    typeHintProviderMock.getEdgeTypeHint.returns(undefined);
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    const node = createNode();
                    const originalCanConnectSpy = sinon.spy(node, 'canConnect');
                    const result = command.execute(createCommandExecutionContext(node));
                    const element = result.children[0];
                    const edge = createEdge();
                    (0, chai_1.expect)(element.canConnect(edge, 'source')).to.be.true;
                    (0, chai_1.expect)(element.canConnect(edge, 'target')).to.be.true;
                    (0, chai_1.expect)(originalCanConnectSpy.called).to.be.true;
                });
            });
            describe('`isContainable` (after hint has been applied to element)', () => {
                const shapeHint = {
                    deletable: false,
                    elementTypeId: 'node',
                    reparentable: false,
                    repositionable: false,
                    resizable: false
                };
                it('should return `false` if corresponding hint has no containable elements defined', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    const result = command.execute(createCommandExecutionContext(createNode('node')));
                    const element = result.children[0];
                    (0, chai_1.expect)(element.isContainableElement('other')).to.be.false;
                });
                it('should return `true` if corresponding hint has containable element with matching type', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    shapeHint.containableElementTypeIds = ['node'];
                    const result = command.execute(createCommandExecutionContext(createNode('node')));
                    const element = result.children[0];
                    (0, chai_1.expect)(element.isContainableElement('node')).to.be.true;
                });
                it('should return `true` if corresponding hint as has containable element with matching super type', () => {
                    typeHintProviderMock.getShapeTypeHint.returns(shapeHint);
                    shapeHint.containableElementTypeIds = ['node'];
                    const result = command.execute(createCommandExecutionContext(createNode('node')));
                    const element = result.children[0];
                    (0, chai_1.expect)(element.isContainableElement('node:task:automated')).to.be.true;
                });
            });
        });
        describe('EdgeTypeHint', () => {
            const allEnabledHint = {
                elementTypeId: 'edge',
                deletable: true,
                repositionable: true,
                routable: true
            };
            const allDisabledHint = {
                elementTypeId: 'edge',
                deletable: false,
                repositionable: false,
                routable: false
            };
            it('should not modify feature set of model element with no applicable type hint', () => {
                typeHintProviderMock.getEdgeTypeHint.returns(undefined);
                const result = command.execute(createCommandExecutionContext(createEdge()));
                const element = result.children[0];
                (0, chai_1.expect)(model_1.GEdge.DEFAULT_FEATURES, 'Element should have default feature set').to.have.same.members([
                    ...element.features
                ]);
            });
            it('should add all enabled (`true`) features, derived from the applied type hint, to the model', () => {
                typeHintProviderMock.getEdgeTypeHint.returns(allEnabledHint);
                const result = command.execute(createCommandExecutionContext(createEdge()));
                const element = result.children[0];
                (0, chai_1.expect)((0, sprotty_1.isDeletable)(element), 'Element should have deletable feature').to.be.true;
                (0, chai_1.expect)(element.hasFeature(sprotty_1.editFeature), 'Element should have edit feature').to.be.true;
                (0, chai_1.expect)((0, model_3.isReconnectable)(element), 'Element should have reconnectable feature').to.be.true;
            });
            it('should remove all disabled (`false`) features, derived from the applied type hint, from the model', () => {
                typeHintProviderMock.getEdgeTypeHint.returns(allDisabledHint);
                const result = command.execute(createCommandExecutionContext(createEdge()));
                const element = result.children[0];
                (0, chai_1.expect)((0, sprotty_1.isDeletable)(element), 'Element should not have deletable feature').to.be.false;
                (0, chai_1.expect)(element.hasFeature(sprotty_1.editFeature), 'Element should  not have edit feature').to.be.false;
                (0, chai_1.expect)((0, model_3.isReconnectable)(element), 'Element should  not have reconnectable feature').to.be.false;
            });
        });
    });
});
//# sourceMappingURL=type-hint-provider.spec.js.map