"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ChangeBoundsTool_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeBoundsListener = exports.ChangeBoundsTool = void 0;
/********************************************************************************
 * Copyright (c) 2019-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = require("inversify");
const sprotty_1 = require("@eclipse-glsp/sprotty");
const drag_aware_mouse_listener_1 = require("../../../base/drag-aware-mouse-listener");
const css_feedback_1 = require("../../../base/feedback/css-feedback");
const selection_service_1 = require("../../../base/selection-service");
const snap_1 = require("../../../features/change-bounds/snap");
const layout_utils_1 = require("../../../utils/layout-utils");
const gmodel_util_1 = require("../../../utils/gmodel-util");
const model_1 = require("../../change-bounds/model");
const movement_restrictor_1 = require("../../change-bounds/movement-restrictor");
const base_tools_1 = require("../base-tools");
const change_bounds_tool_feedback_1 = require("./change-bounds-tool-feedback");
/**
 * The change bounds tool has the license to move multiple elements or resize a single element by implementing the ChangeBounds operation.
 * In contrast to Sprotty's implementation this tool only sends a `ChangeBoundsOperationAction` when an operation has finished and does not
 * provide client-side live updates to improve performance.
 *
 * | Operation | Client Update    | Server Update
 * +-----------+------------------+----------------------------
 * | Move      | MoveAction       | ChangeBoundsOperationAction
 * | Resize    | SetBoundsAction  | ChangeBoundsOperationAction
 *
 * To provide a visual client updates during move we install the `FeedbackMoveMouseListener` and to provide visual client updates during
 * resize and send the server updates we install the `ChangeBoundsListener`.
 */
let ChangeBoundsTool = ChangeBoundsTool_1 = class ChangeBoundsTool extends base_tools_1.BaseEditTool {
    get id() {
        return ChangeBoundsTool_1.ID;
    }
    enable() {
        // install feedback move mouse listener for client-side move updates
        const feedbackMoveMouseListener = this.createMoveMouseListener();
        if (sprotty_1.Disposable.is(feedbackMoveMouseListener)) {
            this.toDisposeOnDisable.push(feedbackMoveMouseListener);
        }
        // install change bounds listener for client-side resize updates and server-side updates
        const changeBoundsListener = this.createChangeBoundsListener();
        if (sprotty_1.Disposable.is(changeBoundsListener)) {
            this.toDisposeOnDisable.push(changeBoundsListener);
        }
        this.toDisposeOnDisable.push(this.mouseTool.registerListener(feedbackMoveMouseListener), this.mouseTool.registerListener(changeBoundsListener), sprotty_1.Disposable.create(() => this.deregisterFeedback(feedbackMoveMouseListener)), sprotty_1.Disposable.create(() => this.deregisterFeedback(changeBoundsListener, [change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackAction.create()])), this.selectionService.onSelectionChanged(change => changeBoundsListener.selectionChanged(change.root, change.selectedElements)));
    }
    createMoveMouseListener() {
        return new change_bounds_tool_feedback_1.FeedbackMoveMouseListener(this);
    }
    createChangeBoundsListener() {
        return new ChangeBoundsListener(this);
    }
};
exports.ChangeBoundsTool = ChangeBoundsTool;
ChangeBoundsTool.ID = 'glsp.change-bounds-tool';
__decorate([
    (0, inversify_1.inject)(selection_service_1.SelectionService),
    __metadata("design:type", selection_service_1.SelectionService)
], ChangeBoundsTool.prototype, "selectionService", void 0);
__decorate([
    (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
    (0, inversify_1.optional)(),
    __metadata("design:type", sprotty_1.EdgeRouterRegistry)
], ChangeBoundsTool.prototype, "edgeRouterRegistry", void 0);
__decorate([
    (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], ChangeBoundsTool.prototype, "snapper", void 0);
__decorate([
    (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], ChangeBoundsTool.prototype, "movementRestrictor", void 0);
exports.ChangeBoundsTool = ChangeBoundsTool = ChangeBoundsTool_1 = __decorate([
    (0, inversify_1.injectable)()
], ChangeBoundsTool);
class ChangeBoundsListener extends drag_aware_mouse_listener_1.DragAwareMouseListener {
    constructor(tool) {
        super();
        this.tool = tool;
        this.pointPositionUpdater = new snap_1.PointPositionUpdater(tool.snapper);
    }
    mouseDown(target, event) {
        super.mouseDown(target, event);
        // If another button than the left mouse button was clicked or we are
        // still on the root element we don't need to execute the tool behavior
        if (event.button !== 0 || target instanceof sprotty_1.GModelRoot) {
            return [];
        }
        // check if we have a resize handle (only single-selection)
        if (this.activeResizeElement && target instanceof model_1.SResizeHandle) {
            this.activeResizeHandle = target;
        }
        else {
            this.setActiveResizeElement(target);
        }
        if (this.activeResizeElement) {
            this.initPosition(event);
        }
        else {
            this.reset();
        }
        return [];
    }
    mouseMove(target, event) {
        super.mouseMove(target, event);
        if (this.isMouseDrag && this.activeResizeHandle) {
            // rely on the FeedbackMoveMouseListener to update the element bounds of selected elements
            // consider resize handles ourselves
            const actions = [
                (0, css_feedback_1.cursorFeedbackAction)(this.activeResizeHandle.isNwSeResize() ? css_feedback_1.CursorCSS.RESIZE_NWSE : css_feedback_1.CursorCSS.RESIZE_NESW),
                (0, css_feedback_1.applyCssClasses)(this.activeResizeHandle, ChangeBoundsListener.CSS_CLASS_ACTIVE)
            ];
            const positionUpdate = this.pointPositionUpdater.updatePosition(target, { x: event.pageX, y: event.pageY }, !event.altKey);
            if (positionUpdate) {
                const resizeActions = this.handleResizeOnClient(positionUpdate);
                actions.push(...resizeActions);
            }
            this.tool.registerFeedback(actions, this);
        }
        return [];
    }
    draggingMouseUp(target, _event) {
        if (this.pointPositionUpdater.isLastDragPositionUndefined()) {
            this.resetPosition();
            return [];
        }
        const actions = [];
        if (this.activeResizeHandle) {
            // Resize
            actions.push(...this.handleResize(this.activeResizeHandle));
        }
        else {
            // Move
            actions.push(...this.handleMoveOnServer(target));
        }
        this.resetPosition();
        this.tool.deregisterFeedback(this, [(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT)]);
        return actions;
    }
    handleMoveOnServer(target) {
        const operations = [];
        operations.push(...this.handleMoveElementsOnServer(target));
        operations.push(...this.handleMoveRoutingPointsOnServer(target));
        if (operations.length > 0) {
            return [sprotty_1.CompoundOperation.create(operations)];
        }
        return operations;
    }
    handleMoveElementsOnServer(target) {
        const result = [];
        const newBounds = [];
        const selectedElements = [];
        (0, gmodel_util_1.forEachElement)(target.index, gmodel_util_1.isNonRoutableSelectedMovableBoundsAware, element => {
            selectedElements.push(element);
        });
        const selectionSet = new Set(selectedElements);
        selectedElements
            .filter(element => !this.isChildOfSelected(selectionSet, element))
            .map(element => this.createElementAndBounds(element))
            .forEach(bounds => newBounds.push(...bounds));
        if (newBounds.length > 0) {
            result.push(sprotty_1.ChangeBoundsOperation.create(newBounds));
        }
        return result;
    }
    isChildOfSelected(selectedElements, element) {
        while (element instanceof sprotty_1.GChildElement) {
            element = element.parent;
            if (selectedElements.has(element)) {
                return true;
            }
        }
        return false;
    }
    handleMoveRoutingPointsOnServer(target) {
        const newRoutingPoints = [];
        const routerRegistry = this.tool.edgeRouterRegistry;
        if (routerRegistry) {
            //  If client routing is enabled -> delegate routingpoints of connected edges to server
            (0, gmodel_util_1.forEachElement)(target.index, gmodel_util_1.isNonRoutableSelectedMovableBoundsAware, element => {
                if (element instanceof sprotty_1.GConnectableElement) {
                    element.incomingEdges
                        .map(connectable => (0, gmodel_util_1.calcElementAndRoutingPoints)(connectable, routerRegistry))
                        .forEach(ear => newRoutingPoints.push(ear));
                    element.outgoingEdges
                        .map(connectable => (0, gmodel_util_1.calcElementAndRoutingPoints)(connectable, routerRegistry))
                        .forEach(ear => newRoutingPoints.push(ear));
                }
            });
        }
        return newRoutingPoints.length > 0 ? [sprotty_1.ChangeRoutingPointsOperation.create(newRoutingPoints)] : [];
    }
    handleResize(activeResizeHandle) {
        const actions = [];
        actions.push((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
        actions.push((0, css_feedback_1.deleteCssClasses)(activeResizeHandle, ChangeBoundsListener.CSS_CLASS_ACTIVE));
        const resizeElement = (0, sprotty_1.findParentByFeature)(activeResizeHandle, model_1.isResizable);
        if (this.isActiveResizeElement(resizeElement)) {
            this.createChangeBoundsAction(resizeElement).forEach(action => actions.push(action));
        }
        return actions;
    }
    selectionChanged(root, selectedElements) {
        if (this.activeResizeElement) {
            if (selectedElements.includes(this.activeResizeElement.id)) {
                // our active element is still selected, nothing to do
                return;
            }
            // try to find some other selected element and mark that active
            for (const elementId of selectedElements.reverse()) {
                const element = root.index.getById(elementId);
                if (element && this.setActiveResizeElement(element)) {
                    return;
                }
            }
            this.reset();
        }
    }
    setActiveResizeElement(target) {
        // check if we have a selected, moveable element (multi-selection allowed)
        const moveableElement = (0, sprotty_1.findParentByFeature)(target, model_1.isBoundsAwareMoveable);
        if ((0, sprotty_1.isSelected)(moveableElement)) {
            // only allow one element to have the element resize handles
            this.activeResizeElement = moveableElement;
            if ((0, model_1.isResizable)(this.activeResizeElement)) {
                this.tool.registerFeedback([change_bounds_tool_feedback_1.ShowChangeBoundsToolResizeFeedbackAction.create(this.activeResizeElement.id)], this.activeResizeElement);
            }
            return true;
        }
        return false;
    }
    isActiveResizeElement(element) {
        return element !== undefined && this.activeResizeElement !== undefined && element.id === this.activeResizeElement.id;
    }
    initPosition(event) {
        this.pointPositionUpdater.updateLastDragPosition({ x: event.pageX, y: event.pageY });
        if (this.activeResizeHandle) {
            const resizeElement = (0, sprotty_1.findParentByFeature)(this.activeResizeHandle, model_1.isResizable);
            this.initialBounds = {
                x: resizeElement.bounds.x,
                y: resizeElement.bounds.y,
                width: resizeElement.bounds.width,
                height: resizeElement.bounds.height
            };
        }
    }
    dispose() {
        this.reset(true);
    }
    reset(resetBounds = false) {
        this.resetFeedback(resetBounds);
        this.resetPosition();
    }
    resetFeedback(resetBounds = false) {
        const resetFeedback = [];
        if (this.activeResizeElement && (0, model_1.isResizable)(this.activeResizeElement)) {
            if (this.initialBounds && this.activeResizeHandle && resetBounds) {
                // we only reset the bounds if an active resize operation was cancelled due to the tool being disabled
                resetFeedback.push(sprotty_1.SetBoundsAction.create([
                    {
                        elementId: this.activeResizeElement.id,
                        newPosition: this.initialBounds,
                        newSize: this.initialBounds
                    }
                ]));
            }
            this.tool.deregisterFeedback(this.activeResizeElement, [change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackAction.create()]);
        }
        resetFeedback.push((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
        this.tool.deregisterFeedback(this, resetFeedback);
    }
    resetPosition() {
        this.activeResizeHandle = undefined;
        this.pointPositionUpdater.resetPosition();
    }
    handleResizeOnClient(positionUpdate) {
        if (!this.activeResizeHandle) {
            return [];
        }
        const resizeElement = (0, sprotty_1.findParentByFeature)(this.activeResizeHandle, model_1.isResizable);
        if (this.isActiveResizeElement(resizeElement)) {
            switch (this.activeResizeHandle.location) {
                case model_1.ResizeHandleLocation.TopLeft:
                    return this.handleTopLeftResize(resizeElement, positionUpdate);
                case model_1.ResizeHandleLocation.TopRight:
                    return this.handleTopRightResize(resizeElement, positionUpdate);
                case model_1.ResizeHandleLocation.BottomLeft:
                    return this.handleBottomLeftResize(resizeElement, positionUpdate);
                case model_1.ResizeHandleLocation.BottomRight:
                    return this.handleBottomRightResize(resizeElement, positionUpdate);
            }
        }
        return [];
    }
    handleTopLeftResize(resizeElement, positionUpdate) {
        return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x + positionUpdate.x, resizeElement.bounds.y + positionUpdate.y, resizeElement.bounds.width - positionUpdate.x, resizeElement.bounds.height - positionUpdate.y);
    }
    handleTopRightResize(resizeElement, positionUpdate) {
        return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x, resizeElement.bounds.y + positionUpdate.y, resizeElement.bounds.width + positionUpdate.x, resizeElement.bounds.height - positionUpdate.y);
    }
    handleBottomLeftResize(resizeElement, positionUpdate) {
        return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x + positionUpdate.x, resizeElement.bounds.y, resizeElement.bounds.width - positionUpdate.x, resizeElement.bounds.height + positionUpdate.y);
    }
    handleBottomRightResize(resizeElement, positionUpdate) {
        return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x, resizeElement.bounds.y, resizeElement.bounds.width + positionUpdate.x, resizeElement.bounds.height + positionUpdate.y);
    }
    createChangeBoundsAction(element) {
        if (this.isValidBoundChange(element, element.bounds, element.bounds)) {
            return [sprotty_1.ChangeBoundsOperation.create([(0, gmodel_util_1.toElementAndBounds)(element)])];
        }
        else if (this.initialBounds) {
            const actions = [];
            if (this.tool.movementRestrictor) {
                actions.push((0, movement_restrictor_1.removeMovementRestrictionFeedback)(element, this.tool.movementRestrictor));
            }
            actions.push(sprotty_1.SetBoundsAction.create([{ elementId: element.id, newPosition: this.initialBounds, newSize: this.initialBounds }]));
            return actions;
        }
        return [];
    }
    createElementAndBounds(element) {
        if (this.isValidBoundChange(element, element.bounds, element.bounds)) {
            return [(0, gmodel_util_1.toElementAndBounds)(element)];
        }
        return [];
    }
    createSetBoundsAction(element, x, y, width, height) {
        const newPosition = { x, y };
        const newSize = { width, height };
        const result = [];
        if (this.isValidBoundChange(element, newPosition, newSize)) {
            if (this.tool.movementRestrictor) {
                result.push((0, movement_restrictor_1.removeMovementRestrictionFeedback)(element, this.tool.movementRestrictor));
            }
            result.push(sprotty_1.SetBoundsAction.create([{ elementId: element.id, newPosition, newSize }]));
        }
        else if (this.isValidSize(element, newSize)) {
            if (this.tool.movementRestrictor) {
                result.push((0, movement_restrictor_1.createMovementRestrictionFeedback)(element, this.tool.movementRestrictor));
            }
            result.push(sprotty_1.SetBoundsAction.create([{ elementId: element.id, newPosition, newSize }]));
        }
        return result;
    }
    snap(position, element, isSnap) {
        return isSnap && this.tool.snapper ? this.tool.snapper.snap(position, element) : { x: position.x, y: position.y };
    }
    isValidBoundChange(element, newPosition, newSize) {
        return this.isValidSize(element, newSize) && this.isValidMove(element, newPosition);
    }
    isValidSize(element, size) {
        return (0, layout_utils_1.isValidSize)(element, size);
    }
    isValidMove(element, newPosition) {
        return (0, layout_utils_1.isValidMove)(element, newPosition, this.tool.movementRestrictor);
    }
}
exports.ChangeBoundsListener = ChangeBoundsListener;
ChangeBoundsListener.CSS_CLASS_ACTIVE = 'active';
//# sourceMappingURL=change-bounds-tool.js.map