"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/********************************************************************************
 * Copyright (c) 2020-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const chai_1 = require("chai");
const inversify_1 = require("inversify");
const sinon = require("sinon");
const sprotty_1 = require("@eclipse-glsp/sprotty");
const default_module_1 = require("./default.module");
const selection_service_1 = require("./selection-service");
let MockFeedbackActionDispatcher = class MockFeedbackActionDispatcher {
    constructor() {
        this.feedbackEmitters = new Map();
    }
    registerFeedback(feedbackEmitter, actions) {
        this.feedbackEmitters.set(feedbackEmitter, actions);
        return sprotty_1.Disposable.create(() => this.deregisterFeedback(feedbackEmitter));
    }
    deregisterFeedback(feedbackEmitter, _actions) {
        this.feedbackEmitters.delete(feedbackEmitter);
    }
    getRegisteredFeedback() {
        const result = [];
        this.feedbackEmitters.forEach((value, key) => result.push(...value));
        return result;
    }
    getSingleFeedbackAction() {
        const actions = this.getRegisteredFeedback();
        return actions.length === 1 ? actions[0] : undefined;
    }
};
MockFeedbackActionDispatcher = __decorate([
    (0, inversify_1.injectable)()
], MockFeedbackActionDispatcher);
class MockSelectionListener {
    selectionChanged(root, selectedElements, deselectedElements) {
        // no.op
    }
}
function createContainer() {
    const container = (0, sprotty_1.initializeContainer)(new inversify_1.Container(), default_module_1.defaultModule);
    // eslint-disable-next-line deprecation/deprecation
    container.rebind(sprotty_1.TYPES.IFeedbackActionDispatcher).to(MockFeedbackActionDispatcher).inSingletonScope();
    return container;
}
describe('SelectionService', () => {
    // eslint-disable-next-line deprecation/deprecation
    let root;
    let selectionService;
    let feedbackDispatcher;
    beforeEach(() => {
        const container = createContainer();
        // eslint-disable-next-line deprecation/deprecation
        root = createRoot('node1', 'node2', 'node3', 'node4', 'node5');
        selectionService = container.get(selection_service_1.SelectionService);
        feedbackDispatcher = container.get(sprotty_1.TYPES.IFeedbackActionDispatcher);
    });
    describe('Initial State', () => {
        it('On creation nothing should be selected and no feedback should be dispatched.', () => {
            assertSelectionAndFeedback([], []);
        });
    });
    describe('Single Selection', () => {
        it('Selecting a single element should be tracked correctly and trigger feedback.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1'], []);
            assertSelectionAndFeedback(['node1'], []);
        });
        it('Selecting the same element twice in one operation should not make a difference.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node1'], []);
            assertSelectionAndFeedback(['node1'], []);
        });
        it('Selecting and then deselecting the same element should result in an empty selection.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1'], []);
            selectionService.updateSelection(root, [], ['node1']);
            assertSelectionAndFeedback([], ['node1']);
        });
        it('Selecting and deselecting the same element in the same operation should have no effect.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1'], ['node1']);
            assertSelectionAndFeedback([], []);
        });
        it('Selecting and deselecting not-existing nodes should have no effect.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['not-existing'], []);
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, [], ['not-existing']);
            assertSelectionAndFeedback([], []);
        });
    });
    describe('Multi Selection', () => {
        it('Selecting multiple elements should be tracked correctly and trigger feedback.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2'], []);
            assertSelectionAndFeedback(['node1', 'node2'], []);
        });
        it('Selecting multiple elements should have the selection order in the dispatched feedback.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node2', 'node1'], []);
            (0, chai_1.expect)(() => assertSelectionAndFeedback(['node1', 'node2'], [])).to.throw(chai_1.AssertionError, 'ordered members');
        });
        it('Selecting the same elements twice in one operation should not make a difference.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node1', 'node2', 'node2'], []);
            assertSelectionAndFeedback(['node1', 'node2'], []);
        });
        it('Selecting and then deselecting the same elements should result in an empty selection.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2'], []);
            selectionService.updateSelection(root, [], ['node1', 'node2']);
            assertSelectionAndFeedback([], ['node1', 'node2']);
        });
        it('Selecting and deselecting the same elements in one operation should have no effect.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2'], ['node1', 'node2']);
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2', 'node3'], ['node1', 'node2']);
            assertSelectionAndFeedback(['node3'], []);
        });
        it('Selecting three elements and deselecting one should result in two selected and one deselected element.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2', 'node3'], []);
            assertSelectionAndFeedback(['node1', 'node2', 'node3'], []);
            selectionService.updateSelection(root, [], ['node2']);
            assertSelectionAndFeedback(['node1', 'node3'], ['node2']);
        });
        it('A series of selection and deselection operations should be tracked correctly.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2', 'node3'], []);
            assertSelectionAndFeedback(['node1', 'node2', 'node3'], []);
            selectionService.updateSelection(root, ['node4'], ['node2']);
            assertSelectionAndFeedback(['node1', 'node3', 'node4'], ['node2']);
            selectionService.updateSelection(root, ['node3', 'node1'], ['node2', 'node4']);
            assertSelectionAndFeedback(['node1', 'node3'], ['node4']);
            selectionService.updateSelection(root, ['node3'], ['node3']);
            assertSelectionAndFeedback(['node1', 'node3'], ['node4']);
        });
    });
    describe('Changing Root', () => {
        it('Changing root deselects all selected elements if there are no matching elements.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1'], []);
            assertSelectionAndFeedback(['node1'], []);
            const newRoot = createRoot('newNode1', 'newNode2', 'newNode3');
            selectionService.modelRootChanged(newRoot);
            assertSelectionAndFeedback([], ['node1']);
        });
        it('Changing root keeps selected elements if there are matching elements.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2'], []);
            assertSelectionAndFeedback(['node1', 'node2'], []);
            const newRoot = createRoot('node1', 'newNode2', 'newNode3');
            selectionService.modelRootChanged(newRoot);
            assertSelectionAndFeedback(['node1'], ['node2']);
        });
        it('Changing root with new selection correctly selects matching elements and deselects not matching elements.', () => {
            assertSelectionAndFeedback([], []);
            selectionService.updateSelection(root, ['node1', 'node2'], []);
            assertSelectionAndFeedback(['node1', 'node2'], []);
            const newRoot = createRoot('newNode1', 'newNode2', 'newNode3');
            selectionService.updateSelection(newRoot, ['newNode1'], []);
            assertSelectionAndFeedback(['newNode1'], ['node1', 'node2']);
        });
    });
    describe('Listeners', () => {
        const sandbox = sinon.createSandbox();
        const listener = sandbox.createStubInstance(MockSelectionListener);
        beforeEach(() => {
            selectionService.onSelectionChanged(change => listener.selectionChanged(change.root, change.selectedElements, change.deselectedElements));
        });
        afterEach(() => {
            selectionService.dispose();
            sandbox.reset();
        });
        it('A registered listener should be notified of a single selection change.', () => {
            selectionService.updateSelection(root, ['node1', 'node1'], []);
            assertListener(listener, root, ['node1'], [], 1);
        });
        it('A registered listener should be notified of a multi-selection change.', () => {
            selectionService.updateSelection(root, ['node1', 'node2', 'node3'], []);
            assertListener(listener, root, ['node1', 'node2', 'node3'], [], 1);
        });
        it('A registered listener should be notified of series of selection changes.', () => {
            selectionService.updateSelection(root, ['node1'], []);
            assertListener(listener, root, ['node1'], [], 1);
            selectionService.updateSelection(root, ['node2'], ['node1']);
            assertListener(listener, root, ['node2'], ['node1'], 2);
            selectionService.updateSelection(root, ['node3', 'node4'], []);
            assertListener(listener, root, ['node2', 'node3', 'node4'], [], 3);
            selectionService.updateSelection(root, [], ['node4']);
            assertListener(listener, root, ['node2', 'node3'], ['node4'], 4);
        });
        it('A registered listener should be notified of root changes.', () => {
            selectionService.updateSelection(root, [], []);
            assertListener(listener, root, [], [], 1);
            const newRoot = createRoot('node1', 'newNode2', 'newNode3');
            selectionService.updateSelection(newRoot, [], []);
            assertListener(listener, newRoot, [], [], 2);
        });
        it('Selecting the same elements consecutively should not trigger a listener update.', () => {
            selectionService.updateSelection(root, ['node1'], []);
            assertListener(listener, root, ['node1'], [], 1);
            selectionService.updateSelection(root, ['node1'], []);
            assertListener(listener, root, ['node1'], [], 1);
        });
        it('Selecting a not-existing elements should not trigger a listener update.', () => {
            selectionService.updateSelection(root, ['node1'], []);
            assertListener(listener, root, ['node1'], [], 1);
            selectionService.updateSelection(root, ['not-existing'], []);
            assertListener(listener, root, ['node1'], [], 1);
        });
    });
    function createRoot(...nodes) {
        const model = new sprotty_1.GModelRoot();
        model.id = 'selection-service-spec';
        model.type = 'graph';
        nodes.forEach(id => {
            const node = new sprotty_1.GNode();
            node.type = 'node:circle';
            node.id = id;
            model.add(node);
        });
        return model;
    }
    function assertSelectionAndFeedback(expectedSelection, expectedDeselection) {
        assertSelectionService(expectedSelection);
        assertDispatchedFeedback(expectedSelection, expectedDeselection);
    }
    function assertSelectionService(expectedSelection) {
        (0, chai_1.expect)(selectionService.isSingleSelection()).to.equal(expectedSelection.length === 1);
        (0, chai_1.expect)(selectionService.isMultiSelection()).to.equal(expectedSelection.length > 1);
        (0, chai_1.expect)(selectionService.hasSelectedElements()).to.equal(expectedSelection.length > 0);
        (0, chai_1.expect)(selectionService.getSelectedElementIDs()).to.have.lengthOf(expectedSelection.length);
        if (expectedSelection.length > 0) {
            (0, chai_1.expect)(selectionService.getSelectedElementIDs()).to.have.ordered.members(expectedSelection);
        }
    }
    function assertDispatchedFeedback(expectedSelection, expectedDeselection) {
        // a single feedback action reflects aggregated selection/deselection
        const hasFeedback = expectedSelection.length > 0 || expectedDeselection.length > 0;
        if (hasFeedback) {
            (0, chai_1.expect)(feedbackDispatcher.getRegisteredFeedback()).to.have.lengthOf(1);
            (0, chai_1.expect)(feedbackDispatcher.getSingleFeedbackAction().selectedElementsIDs).to.have.lengthOf(expectedSelection.length);
            (0, chai_1.expect)(feedbackDispatcher.getSingleFeedbackAction().selectedElementsIDs).to.have.ordered.members(expectedSelection);
            (0, chai_1.expect)(feedbackDispatcher.getSingleFeedbackAction().deselectedElementsIDs).to.have.lengthOf(expectedDeselection.length);
            (0, chai_1.expect)(feedbackDispatcher.getSingleFeedbackAction().deselectedElementsIDs).to.have.ordered.members(expectedDeselection);
        }
        else {
            (0, chai_1.expect)(feedbackDispatcher.getRegisteredFeedback()).to.have.lengthOf(0);
            (0, chai_1.expect)(feedbackDispatcher.getSingleFeedbackAction()).to.be.undefined;
        }
    }
    function assertListener(listener, expectedRoot, expectedSelection, expectedDeselection, expectedCalled) {
        (0, chai_1.expect)(listener.selectionChanged.callCount).to.be.equal(expectedCalled);
        (0, chai_1.expect)(listener.selectionChanged.lastCall.args[0]).to.be.deep.equals(expectedRoot);
        (0, chai_1.expect)(listener.selectionChanged.lastCall.args[1]).to.be.deep.equals(expectedSelection);
        (0, chai_1.expect)(listener.selectionChanged.lastCall.args[2]).to.be.deep.equals(expectedDeselection);
    }
});
//# sourceMappingURL=selection-service.spec.js.map