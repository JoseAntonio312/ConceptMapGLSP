/// <reference types="node" />
import { Action, ActionDispatcher, RequestAction, ResponseAction } from '@eclipse-glsp/sprotty';
import { ModelInitializationConstraint } from './model/model-initialization-constraint';
export declare class GLSPActionDispatcher extends ActionDispatcher {
    protected readonly timeouts: Map<string, NodeJS.Timeout>;
    protected initializedConstraint: boolean;
    protected initializationConstraint: ModelInitializationConstraint;
    initialize(): Promise<void>;
    startModelInitialization(): void;
    onceModelInitialized(): Promise<void>;
    hasHandler(action: Action): boolean;
    /**
     * Processes all given actions, by dispatching them to the corresponding handlers, after the model initialization is completed.
     *
     * @param actions The actions that should be dispatched after the model initialization
     */
    dispatchOnceModelInitialized(...actions: Action[]): void;
    dispatch(action: Action): Promise<void>;
    protected handleAction(action: Action): Promise<void>;
    request<Res extends ResponseAction>(action: RequestAction<Res>): Promise<Res>;
    /**
     * Dispatch a request and waits for a response until the timeout given in `timeoutMs` has
     * been reached. The returned promise is resolved when a response with matching identifier
     * is dispatched or when the timeout has been reached. That response is _not_ passed to the
     * registered action handlers. Instead, it is the responsibility of the caller of this method
     * to handle the response properly. For example, it can be sent to the registered handlers by
     * passing it again to the `dispatch` method.
     * If `rejectOnTimeout` is set to false (default) the returned promise will be resolved with
     * no value, otherwise it will be rejected.
     */
    requestUntil<Res extends ResponseAction>(action: RequestAction<Res>, timeoutMs?: number, rejectOnTimeout?: boolean): Promise<Res | undefined>;
}
//# sourceMappingURL=action-dispatcher.d.ts.map