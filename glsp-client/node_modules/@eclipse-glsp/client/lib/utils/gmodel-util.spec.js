"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const chai_1 = require("chai");
const inversify_1 = require("inversify");
const routing_module_1 = require("../features/routing/routing-module");
const gmodel_util_1 = require("./gmodel-util");
const model_1 = require("../model");
class TestRouter extends sprotty_1.AbstractEdgeRouter {
    constructor() {
        super(...arguments);
        this.kind = 'test-router';
    }
    route(edge) {
        const pureRoute = edge.routingPoints.map((point, idx) => (Object.assign(Object.assign({ kind: 'linear' }, point), { pointIndex: idx })));
        return [
            Object.assign({ kind: 'source' }, edge.source.position),
            ...pureRoute,
            { kind: 'bezier-control-after', x: 999, y: 999, pointIndex: pureRoute.length },
            Object.assign({ kind: 'target' }, edge.target.position)
        ];
    }
    createRoutingHandles(edge) {
        // do nothing
    }
    getOptions(edge) {
        return {
            minimalPointDistance: 0,
            selfEdgeOffset: 0,
            standardDistance: 0
        };
    }
    getInnerHandlePosition(edge, route, handle) {
        return undefined;
    }
    applyInnerHandleMoves(edge, moves) {
        // do nothing
    }
}
describe('SModel Util', () => {
    describe('calcRoute', () => {
        const graph = new model_1.GGraph();
        const source = new sprotty_1.GNode();
        source.id = 'node0';
        source.position = { x: 0, y: 0 };
        source.size = { width: 0, height: 0 };
        graph.add(source);
        const target = new sprotty_1.GNode();
        target.id = 'node1';
        target.position = { x: 100, y: 100 };
        target.size = { width: 0, height: 0 };
        graph.add(target);
        const edge = new model_1.GEdge();
        edge.id = 'edge0';
        edge.sourceId = 'node0';
        edge.targetId = 'node1';
        graph.add(edge);
        edge.routerKind = 'test-router';
        const container = new inversify_1.Container();
        container.load(routing_module_1.routingModule);
        const routerRegistry = container.get(sprotty_1.EdgeRouterRegistry);
        routerRegistry.register('test-router', new TestRouter());
        it('should return complete route', () => {
            edge.source.position = { x: 0, y: 0 };
            edge.target.position = { x: 100, y: 100 };
            edge.routingPoints = [
                { x: 20, y: 20 },
                { x: 30, y: 30 },
                { x: 40, y: 40 }
            ];
            const route = (0, gmodel_util_1.calcRoute)(edge, routerRegistry);
            (0, chai_1.expect)(route).to.deep.equal([
                { x: 0, y: 0, kind: 'source' },
                { x: 20, y: 20, kind: 'linear', pointIndex: 0 },
                { x: 30, y: 30, kind: 'linear', pointIndex: 1 },
                { x: 40, y: 40, kind: 'linear', pointIndex: 2 },
                { x: 999, y: 999, kind: 'bezier-control-after', pointIndex: 3 },
                { x: 100, y: 100, kind: 'target' }
            ]);
        });
        it('should filter duplicates with same coordinates', () => {
            edge.source.position = { x: 0, y: 0 };
            edge.target.position = { x: 100, y: 100 };
            edge.routingPoints = [
                { x: 20, y: 20 },
                { x: 20, y: 20 },
                { x: 30, y: 30 },
                { x: 40, y: 40 }
            ];
            const route = (0, gmodel_util_1.calcRoute)(edge, routerRegistry);
            (0, chai_1.expect)(route).to.deep.equal([
                { x: 0, y: 0, kind: 'source' },
                { x: 20, y: 20, kind: 'linear', pointIndex: 0 },
                { x: 30, y: 30, kind: 'linear', pointIndex: 2 },
                { x: 40, y: 40, kind: 'linear', pointIndex: 3 },
                { x: 999, y: 999, kind: 'bezier-control-after', pointIndex: 4 },
                { x: 100, y: 100, kind: 'target' }
            ]);
        });
        it('should not filter source and target even if duplicate coordinates', () => {
            edge.source.position = { x: 0, y: 0 };
            edge.target.position = { x: 0, y: 0 };
            edge.routingPoints = [
                { x: 20, y: 20 },
                { x: 30, y: 30 },
                { x: 40, y: 40 }
            ];
            const route = (0, gmodel_util_1.calcRoute)(edge, routerRegistry);
            (0, chai_1.expect)(route).to.deep.equal([
                { x: 0, y: 0, kind: 'source' },
                { x: 20, y: 20, kind: 'linear', pointIndex: 0 },
                { x: 30, y: 30, kind: 'linear', pointIndex: 1 },
                { x: 40, y: 40, kind: 'linear', pointIndex: 2 },
                { x: 999, y: 999, kind: 'bezier-control-after', pointIndex: 3 },
                { x: 0, y: 0, kind: 'target' }
            ]);
        });
        it('should filter duplicates with same coordinates but allow tolerance', () => {
            edge.source.position = { x: 0, y: 0 };
            edge.target.position = { x: 100, y: 100 };
            edge.routingPoints = [
                { x: 20, y: 20 },
                { x: 25, y: 25 },
                { x: 30, y: 30 },
                { x: 40, y: 40 }
            ];
            const route = (0, gmodel_util_1.calcRoute)(edge, routerRegistry, gmodel_util_1.ALL_ROUTING_POINTS, 10);
            (0, chai_1.expect)(route).to.deep.equal([
                { x: 0, y: 0, kind: 'source' },
                { x: 20, y: 20, kind: 'linear', pointIndex: 0 },
                { x: 30, y: 30, kind: 'linear', pointIndex: 2 },
                { x: 40, y: 40, kind: 'linear', pointIndex: 3 },
                { x: 999, y: 999, kind: 'bezier-control-after', pointIndex: 4 },
                { x: 100, y: 100, kind: 'target' }
            ]);
        });
        it('should allow filtering based on point type: ROUTE_KINDS', () => {
            edge.source.position = { x: 0, y: 0 };
            edge.target.position = { x: 100, y: 100 };
            edge.routingPoints = [
                { x: 20, y: 20 },
                { x: 30, y: 30 },
                { x: 40, y: 40 }
            ];
            const route = (0, gmodel_util_1.calcRoute)(edge, routerRegistry, gmodel_util_1.ROUTE_KINDS);
            (0, chai_1.expect)(route).to.deep.equal([
                { x: 0, y: 0, kind: 'source' },
                { x: 20, y: 20, kind: 'linear', pointIndex: 0 },
                { x: 30, y: 30, kind: 'linear', pointIndex: 1 },
                { x: 40, y: 40, kind: 'linear', pointIndex: 2 },
                { x: 100, y: 100, kind: 'target' }
            ]);
        });
        it('should allow filtering based on point type: ROUTING_POINT_KINDS', () => {
            edge.source.position = { x: 0, y: 0 };
            edge.target.position = { x: 100, y: 100 };
            edge.routingPoints = [
                { x: 20, y: 20 },
                { x: 30, y: 30 },
                { x: 40, y: 40 }
            ];
            const route = (0, gmodel_util_1.calcRoute)(edge, routerRegistry, gmodel_util_1.ROUTING_POINT_KINDS);
            (0, chai_1.expect)(route).to.deep.equal([
                { x: 20, y: 20, kind: 'linear', pointIndex: 0 },
                { x: 30, y: 30, kind: 'linear', pointIndex: 1 },
                { x: 40, y: 40, kind: 'linear', pointIndex: 2 }
            ]);
        });
    });
});
//# sourceMappingURL=gmodel-util.spec.js.map