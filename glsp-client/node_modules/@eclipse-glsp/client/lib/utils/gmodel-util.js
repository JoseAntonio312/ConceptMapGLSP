"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getElementTypeId = exports.calcRoute = exports.calcElementAndRoute = exports.calcElementAndRoutingPoints = exports.ROUTE_KINDS = exports.ROUTING_POINT_KINDS = exports.ALL_ROUTING_POINTS = exports.toElementAndRoutingPoints = exports.toElementAndBounds = exports.isSelectableAndBoundsAware = exports.isRoutingHandle = exports.isRoutable = exports.isNonRoutableSelectedBoundsAware = exports.isNonRoutableSelectedMovableBoundsAware = exports.removeCssClasses = exports.addCssClasses = exports.isNotUndefined = exports.hasSelectedElements = exports.getSelectedElementCount = exports.getElements = exports.getMatchingElements = exports.forEachElement = exports.filter = void 0;
/********************************************************************************
 * Copyright (c) 2019-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
/**
 * Retrieves all elements from the given {@link ModelIndexImpl} that match the given {@link ModelFilterPredicate}
 * @param index The {@link ModelIndexImpl}.
 * @param predicate The {@link ModelFilterPredicate} that should be used.
 * @returns A {@link FluentIterable} of all indexed element that match the predicate
 * (correctly casted to also include the additional type of the predicate).
 */
function filter(index, predicate) {
    return index.all().filter(predicate);
}
exports.filter = filter;
/**
 * Retrieves all elements from the given {@link ModelIndexImpl} that match the given {@link ModelFilterPredicate} and executes
 * the given runnable for each element of the result set.
 * @param index The {@link ModelIndexImpl}.
 * @param predicate The {@link ModelFilterPredicate} that should be used.
 * @param runnable The runnable that should be executed for each matching element.
 */
function forEachElement(index, predicate, runnable) {
    filter(index, predicate).forEach(runnable);
}
exports.forEachElement = forEachElement;
/**
 * Retrieves an array of all elements that match the given {@link ModelFilterPredicate} from the given {@link ModelIndexImpl}.
 * @param index The {@link ModelIndexImpl}.
 * @param predicate The {@link ModelFilterPredicate} that should be used.
 * @returns An array of all indexed element that match the predicate
 * (correctly casted to also include the additional type of the predicate).
 */
function getMatchingElements(index, predicate) {
    return Array.from(filter(index, predicate));
}
exports.getMatchingElements = getMatchingElements;
/**
 * Invokes the given model index to retrieve the corresponding model elements for the given set of ids. Ids that
 * have no corresponding element in the index will be ignored.
 * @param index THe model index.
 * @param elementsIDs The element ids.
 * @param guard Optional typeguard. If defined only elements that match the guard will be returned.
 * @returns An array of the model elements that correspond to the given ids and filter predicate.
 */
function getElements(index, elementsIDs, guard) {
    // Internal filter function that filters out undefined model elements and runs an optional typeguard check.
    const filterFn = (element) => {
        if (element !== undefined) {
            return guard ? guard(element) : true;
        }
        return false;
    };
    return elementsIDs.map(id => index.getById(id)).filter(filterFn);
}
exports.getElements = getElements;
/**
 * Retrieves the amount of currently selected elements in the given {@link ModelIndexImpl}.
 * @param index The {@link ModelIndexImpl}.
 * @returns The amount of selected elements.
 */
function getSelectedElementCount(index) {
    let selected = 0;
    forEachElement(index, sprotty_1.isSelected, element => selected++);
    return selected;
}
exports.getSelectedElementCount = getSelectedElementCount;
/**
 * Helper function to check wether an any element is selected in the given {@link ModelIndexImpl}.
 * @param index The {@link ModelIndexImpl}.
 * @returns `true` if at least one element is selected, `false` otherwise.
 */
function hasSelectedElements(index) {
    return getSelectedElementCount(index) > 0;
}
exports.hasSelectedElements = hasSelectedElements;
/**
 * Helper function to check wether an element is defined. Can be used as {@link ModelFilterPredicate}.
 * @param element The element that should be checked.
 * @returns the type predicate for `T`
 */
function isNotUndefined(element) {
    return element !== undefined;
}
exports.isNotUndefined = isNotUndefined;
/**
 * Adds a set of css classes to the given {@link GModelElement}.
 * @param element The element to which the css classes should be added.
 * @param cssClasses The set of css classes as string array.
 */
function addCssClasses(element, cssClasses) {
    var _a;
    const elementCssClasses = (_a = element.cssClasses) !== null && _a !== void 0 ? _a : [];
    (0, sprotty_1.distinctAdd)(elementCssClasses, ...cssClasses);
    element.cssClasses = elementCssClasses;
}
exports.addCssClasses = addCssClasses;
/**
 * Removes a set of css classes from the given {@link GModelElement}.
 * @param element The element from which the css classes should be removed.
 * @param cssClasses The set of css classes as string array.
 */
function removeCssClasses(root, cssClasses) {
    if (!root.cssClasses || root.cssClasses.length === 0) {
        return;
    }
    (0, sprotty_1.remove)(root.cssClasses, ...cssClasses);
}
exports.removeCssClasses = removeCssClasses;
function isNonRoutableSelectedMovableBoundsAware(element) {
    return isNonRoutableSelectedBoundsAware(element) && (0, sprotty_1.isMoveable)(element);
}
exports.isNonRoutableSelectedMovableBoundsAware = isNonRoutableSelectedMovableBoundsAware;
/**
 * A typeguard function to check wether a given {@link GModelElement} implements the {@link BoundsAware} model feature,
 * the {@link Selectable} model feature and is actually selected. In addition, the element must not be a {@link GRoutableElement}.
 * @param element The element to check.
 * @returns A type predicate indicating wether the element is of type {@link SelectableBoundsAware}.
 */
function isNonRoutableSelectedBoundsAware(element) {
    return (0, sprotty_1.isBoundsAware)(element) && (0, sprotty_1.isSelected)(element) && !isRoutable(element);
}
exports.isNonRoutableSelectedBoundsAware = isNonRoutableSelectedBoundsAware;
/**
 * A type guard function to check wether a given {@link GModelElement} is a {@link GRoutableElement}.
 * @param element The element to check.
 * @returns A type predicate indicating wether the element is a {@link GRoutableElement}.
 */
function isRoutable(element) {
    return element instanceof sprotty_1.GRoutableElement && element.routingPoints !== undefined;
}
exports.isRoutable = isRoutable;
/**
 * A typeguard function to check wether a given {@link GModelElement} is a {@link SRoutingHandle}.
 * @param element The element to check.
 * @returns A type predicate indicating wether the element is a {@link SRoutingHandle}
 */
function isRoutingHandle(element) {
    return element !== undefined && element instanceof sprotty_1.GRoutingHandle;
}
exports.isRoutingHandle = isRoutingHandle;
/**
 * A typeguard function to check wether a given {@link GModelElement} implements the {@link Selectable} model feature and
 * the {@link BoundsAware} model feature.
 * @returns A type predicate indicating wether the element is of type {@link SelectableBoundsAware}.
 */
function isSelectableAndBoundsAware(element) {
    return (0, sprotty_1.isSelectable)(element) && (0, sprotty_1.isBoundsAware)(element);
}
exports.isSelectableAndBoundsAware = isSelectableAndBoundsAware;
/**
 * Helper function to translate a given {@link GModelElement} into its corresponding {@link ElementAndBounds} representation.
 * @param element The element to translate.
 * @returns The corresponding {@link ElementAndBounds} for the given element.
 */
function toElementAndBounds(element) {
    return {
        elementId: element.id,
        newPosition: {
            x: element.bounds.x,
            y: element.bounds.y
        },
        newSize: {
            width: element.bounds.width,
            height: element.bounds.height
        }
    };
}
exports.toElementAndBounds = toElementAndBounds;
/**
 * Helper function to translate a given {@link GRoutableElement} into its corresponding
 * {@link ElementAndRoutingPoints} representation.
 * @param element The element to translate.
 * @returns The corresponding {@link ElementAndRoutingPoints} for the given element.
 */
function toElementAndRoutingPoints(element) {
    return {
        elementId: element.id,
        newRoutingPoints: element.routingPoints
    };
}
exports.toElementAndRoutingPoints = toElementAndRoutingPoints;
/** All routing points. */
exports.ALL_ROUTING_POINTS = undefined;
/** Pure routing point data kinds. */
exports.ROUTING_POINT_KINDS = ['linear', 'bezier-junction'];
/** Pure route data kinds. */
exports.ROUTE_KINDS = [...exports.ROUTING_POINT_KINDS, 'source', 'target'];
/**
 * Helper function to calculate the {@link ElementAndRoutingPoints} for a given {@link GRoutableElement}.
 * If client layout is activated, i.e., the edge routing registry is given and has a router for the element, then the routing
 * points from the calculated route are used, otherwise we use the already specified routing points of the {@link GRoutableElement}.
 * @param element The element to translate.
 * @param routerRegistry the edge router registry.
 * @returns The corresponding {@link ElementAndRoutingPoints} for the given element.
 */
function calcElementAndRoutingPoints(element, routerRegistry) {
    const newRoutingPoints = routerRegistry ? calcRoute(element, routerRegistry, exports.ROUTING_POINT_KINDS) : element.routingPoints;
    return { elementId: element.id, newRoutingPoints };
}
exports.calcElementAndRoutingPoints = calcElementAndRoutingPoints;
/**
 * Helper function to calculate the route for a given {@link GRoutableElement}.
 * If client layout is activated, i.e., the edge routing registry is given and has a router for the element, then the points
 * from the calculated route are used, otherwise we use the already specified routing points of the {@link GRoutableElement}.
 * @param element The element to translate.
 * @param routerRegistry the edge router registry.
 * @returns The corresponding route for the given element.
 */
function calcElementAndRoute(element, routerRegistry) {
    var _a, _b;
    let route = routerRegistry ? calcRoute(element, routerRegistry, exports.ROUTE_KINDS) : undefined;
    if (!route) {
        // add source and target to the routing points
        route = [...element.routingPoints];
        route.splice(0, 0, ((_a = element.source) === null || _a === void 0 ? void 0 : _a.position) || sprotty_1.Point.ORIGIN);
        route.push(((_b = element.target) === null || _b === void 0 ? void 0 : _b.position) || sprotty_1.Point.ORIGIN);
    }
    return { elementId: element.id, newRoutingPoints: route };
}
exports.calcElementAndRoute = calcElementAndRoute;
/**
 * Helper function to calculate the route for a given {@link GRoutableElement} by filtering duplicate points.
 * @param element The element to translate.
 * @param routerRegistry the edge router registry.
 * @param pointKinds the routing point kinds that should be considered.
 * @param tolerance the tolerance applied to a point's coordinates to determine duplicates.
 * @returns The corresponding route for the given element.
 */
function calcRoute(element, routerRegistry, pointKinds = exports.ALL_ROUTING_POINTS, tolerance = Number.EPSILON) {
    const route = routerRegistry.get(element.routerKind).route(element);
    const calculatedRoute = [];
    for (const point of route) {
        // only include points we are actually interested in
        if (pointKinds && !pointKinds.includes(point.kind)) {
            continue;
        }
        // check if we are a duplicate based on coordinates in the already calculated route
        if (exports.ROUTING_POINT_KINDS.includes(point.kind) &&
            calculatedRoute.find(calculatedPoint => sprotty_1.Point.maxDistance(point, calculatedPoint) < tolerance)) {
            continue;
        }
        calculatedRoute.push(point);
    }
    return calculatedRoute;
}
exports.calcRoute = calcRoute;
/**
 * Convenience function to retrieve the model element type from a given input. The input
 * can either be a {@link GModelElement}, {@link GModelElementSchema} or a string.
 * @param input The type input.
 * @returns The corresponding model type as string.
 */
function getElementTypeId(input) {
    if (typeof input === 'string') {
        return input;
    }
    else {
        return input.type;
    }
}
exports.getElementTypeId = getElementTypeId;
//# sourceMappingURL=gmodel-util.js.map